{
  "version": 3,
  "sources": ["../lib/IDBPaging.ts"],
  "sourcesContent": ["import * as idbx from \"npm:idbx\";\n\nexport interface IDBPagingIndexOptions {\n  indexName?: string;\n  indexKey?: IDBValidKey;\n}\n\nexport interface IDBPagingPageSizeOptions extends IDBPagingIndexOptions {\n  startPage?: number;\n}\n\nexport interface IDBPagingCommandOptions extends IDBPagingIndexOptions {\n  noCheck?: boolean;\n  circularPaging?: boolean;\n}\n\nconst PAGE_NUMBER = Symbol(\"pageNumber\");\n\nexport class IDBPaging<T> {\n  db: IDBDatabase;\n  storeName: string;\n  pageSize: number;\n  [PAGE_NUMBER]: number | null = null;\n  get pageNumber() {\n    return this[PAGE_NUMBER] === null ? 1 : this[PAGE_NUMBER];\n  }\n  totalPages: number;\n  list: T[];\n\n  constructor(\n    db: IDBDatabase,\n    storeName: string,\n    pageSize = 10,\n  ) {\n    this.db = db;\n    this.storeName = storeName;\n    this.pageSize = pageSize ?? 10;\n    this.totalPages = 0;\n    this.list = [];\n  }\n\n  async setPageSize(\n    pageSize: number,\n    options: number | IDBPagingPageSizeOptions = 1,\n  ) {\n    if (pageSize < 1) {\n      throw new Error(\"pageSize must be greater than 0\");\n    }\n\n    const startPageNumber = typeof options === \"number\"\n      ? options\n      : options.startPage ?? 1;\n    options = typeof options === \"number\" ? {} : options;\n\n    this.pageSize = pageSize;\n    await this.go(startPageNumber, options);\n  }\n\n  async calculateLastPageNumber(options?: IDBPagingIndexOptions) {\n    const count = await this.count(options);\n    this.totalPages = Math.ceil(count / this.pageSize);\n    return this.totalPages;\n  }\n\n  async calculatePageNumber(\n    pageNumber: number | string,\n    options: IDBPagingCommandOptions = {},\n  ): Promise<void> {\n    const noCheck = options.noCheck === undefined ? false : options.noCheck;\n    const circularPaging = options.circularPaging === undefined\n      ? false\n      : options.circularPaging;\n\n    this[PAGE_NUMBER] = parseInt(pageNumber.toString(), 10) ?? this.pageNumber;\n    if (!noCheck || circularPaging) {\n      const lastPageNumber = await this.calculateLastPageNumber(options);\n      if (this.pageNumber < 1) {\n        if (circularPaging) {\n          const flipPages = Math.abs(this.pageNumber) % lastPageNumber;\n          this[PAGE_NUMBER] = flipPages >= 0 ? lastPageNumber - flipPages : 1;\n        } else {\n          this[PAGE_NUMBER] = 1;\n        }\n      } else {\n        if (this.pageNumber > lastPageNumber) {\n          if (circularPaging) {\n            const flipPages = this.pageNumber % lastPageNumber;\n            this[PAGE_NUMBER] = flipPages > 0 ? flipPages : lastPageNumber;\n          } else {\n            this[PAGE_NUMBER] = lastPageNumber;\n          }\n        }\n      }\n    }\n  }\n\n  async go(pageNumber: number, options: IDBPagingCommandOptions = {\n    noCheck: false,\n    circularPaging: false,\n  }): Promise<T[]> {\n    await this.calculatePageNumber(pageNumber, options);\n    const offset = (this.pageNumber - 1) * this.pageSize;\n    let advancing = true;\n\n    this.list = await new Promise((resolve) => {\n      const list: T[] = [];\n\n      let store: IDBObjectStore | IDBIndex = idbx.getStore(\n        this.db,\n        this.storeName,\n      );\n      const index = options?.indexName !== undefined\n        ? store.index(options.indexName)\n        : null;\n\n      store = index !== null ? index : store;\n      idbx.cursorHandler(store as any, (cursor) => {\n        if (advancing && offset > 0) {\n          advancing = false;\n          cursor.advance(offset);\n        } else {\n          if (this.pageSize >= list.length) {\n            if (!options?.indexKey || cursor.key === options?.indexKey) {\n              list.push(cursor.value);\n            }\n          }\n          if (this.pageSize === list.length) {\n            // early exit\n            return true;\n          } else {\n            cursor.continue();\n          }\n        }\n      }, () => resolve(list));\n    });\n\n    return this.list;\n  }\n\n  next(\n    pages = 1,\n    options: boolean | IDBPagingCommandOptions = false,\n  ) {\n    if (typeof options === \"boolean\") {\n      options = { circularPaging: options };\n    }\n    const pageNumber = this.pageNumber + Math.abs(pages);\n    return this.go(pageNumber, options);\n  }\n\n  prev(\n    pages = 1,\n    options: boolean | IDBPagingCommandOptions = false,\n  ) {\n    if (typeof options === \"boolean\") {\n      options = { circularPaging: options };\n    }\n    const pageNumber = this.pageNumber - Math.abs(pages);\n    return this.go(pageNumber, options);\n  }\n\n  first(options?: IDBPagingIndexOptions) {\n    return this.go(1, options);\n  }\n\n  async last(\n    options?: IDBPagingIndexOptions,\n  ) {\n    const lastPageNumber = this.totalPages === 0\n      ? await this.calculateLastPageNumber(options)\n      : this.totalPages;\n\n    // noCheck is true because we already know the last page number\n    return this.go(lastPageNumber, { ...options, noCheck: true });\n  }\n\n  count(options?: IDBPagingIndexOptions) {\n    let store: IDBObjectStore | IDBIndex = idbx.getStore(\n      this.db,\n      this.storeName,\n    );\n    const index = options?.indexName !== undefined\n      ? store.index(options.indexName)\n      : null;\n    store = index !== null ? index : store;\n    const req = store.count(options?.indexKey);\n    return new Promise<number>((resolve, reject) => {\n      req.onsuccess = () => {\n        resolve(req.result);\n      };\n      req.onerror = () => {\n        reject(\"Error retrieving data from IndexedDB\");\n      };\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["idbx", "PAGE_NUMBER", "IDBPaging", "db", "storeName", "pageSize", "options", "startPageNumber", "count", "pageNumber", "noCheck", "circularPaging", "lastPageNumber", "flipPages", "offset", "advancing", "resolve", "list", "store", "index", "cursor", "pages", "req", "reject"]
}
