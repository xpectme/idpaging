{
  "version": 3,
  "sources": ["../lib/IDBPaging.ts"],
  "sourcesContent": ["import * as idbx from \"npm:idbx\";\n\nexport interface IDBPagingIndexOptions {\n  index?: string;\n  query?: IDBValidKey | IDBKeyRange;\n  direction?: IDBCursorDirection;\n}\n\nexport interface IDBPagingPageSizeOptions extends IDBPagingIndexOptions {\n  startPage?: number;\n  pageSize?: number;\n}\n\nexport interface IDBPagingCommandOptions extends IDBPagingIndexOptions {\n  noCheck?: boolean;\n  circularPaging?: boolean;\n}\n\nconst PAGE_NUMBER = Symbol(\"pageNumber\");\n\nexport class IDBPaging<T> {\n  db: IDBDatabase;\n  storeName: string;\n  indexName?: string;\n  query?: IDBValidKey | IDBKeyRange;\n  direction?: IDBCursorDirection;\n  pageSize: number;\n  [PAGE_NUMBER]: number | null = null;\n  get pageNumber() {\n    return this[PAGE_NUMBER] === null ? 1 : this[PAGE_NUMBER];\n  }\n  totalPages: number;\n  list: T[];\n\n  constructor(\n    db: IDBDatabase,\n    storeName: string,\n    options: number | IDBPagingPageSizeOptions = 10,\n  ) {\n    this.db = db;\n    this.storeName = storeName;\n    if (typeof options === \"number\") {\n      this.pageSize = options;\n    } else {\n      this.pageSize = options.pageSize ?? 10;\n      this[PAGE_NUMBER] = options.startPage ?? 1;\n      this.indexName = options.index;\n      this.query = options.query;\n      this.direction = options.direction;\n    }\n    this.totalPages = 0;\n    this.list = [];\n  }\n\n  async setPageSize(\n    pageSize: number,\n    options: number | IDBPagingPageSizeOptions = 1,\n  ) {\n    if (pageSize < 1) {\n      throw new Error(\"pageSize must be greater than 0\");\n    }\n\n    const startPageNumber = typeof options === \"number\"\n      ? options\n      : options.startPage ?? 1;\n    options = typeof options === \"number\" ? {} : options;\n\n    this.pageSize = pageSize;\n    await this.go(startPageNumber, options);\n  }\n\n  async calculateLastPageNumber(options?: IDBPagingIndexOptions) {\n    const count = await this.count(options);\n    this.totalPages = Math.ceil(count / this.pageSize);\n    return this.totalPages;\n  }\n\n  async calculatePageNumber(\n    pageNumber: number | string,\n    options: IDBPagingCommandOptions = {},\n  ): Promise<void> {\n    const noCheck = options.noCheck === undefined ? false : options.noCheck;\n    const circularPaging = options.circularPaging === undefined\n      ? false\n      : options.circularPaging;\n\n    this[PAGE_NUMBER] = parseInt(pageNumber.toString(), 10) ?? this.pageNumber;\n    if (!noCheck || circularPaging) {\n      const lastPageNumber = await this.calculateLastPageNumber(options);\n      if (this.pageNumber < 1) {\n        if (circularPaging) {\n          const flipPages = Math.abs(this.pageNumber) % lastPageNumber;\n          this[PAGE_NUMBER] = flipPages >= 0 ? lastPageNumber - flipPages : 1;\n        } else {\n          this[PAGE_NUMBER] = 1;\n        }\n      } else {\n        if (this.pageNumber > lastPageNumber) {\n          if (circularPaging) {\n            const flipPages = this.pageNumber % lastPageNumber;\n            this[PAGE_NUMBER] = flipPages > 0 ? flipPages : lastPageNumber;\n          } else {\n            this[PAGE_NUMBER] = lastPageNumber;\n          }\n        }\n      }\n    }\n  }\n\n  async go(pageNumber: number, options: IDBPagingCommandOptions = {\n    noCheck: false,\n    circularPaging: false,\n  }): Promise<T[]> {\n    await this.calculatePageNumber(pageNumber, options);\n    const offset = (this.pageNumber - 1) * this.pageSize;\n    let advancing = true;\n\n    const index = options.index ?? this.indexName;\n    const query = options.query ?? this.query;\n    const direction = options.direction ?? this.direction;\n\n    this.list = await new Promise((resolve) => {\n      const list: T[] = [];\n\n      const store = index !== undefined\n        ? idbx.getIndex(this.db, this.storeName, index)\n        : idbx.getStore(this.db, this.storeName);\n\n      const request = store.openCursor(query, direction);\n      idbx.cursorHandler(request, (cursor) => {\n        if (advancing && offset > 0) {\n          advancing = false;\n          cursor.advance(offset);\n        } else {\n          if (this.pageSize >= list.length) {\n            if (!options?.query || cursor.key === options?.query) {\n              list.push(cursor.value);\n            }\n          }\n          if (this.pageSize === list.length) {\n            // early exit\n            return true;\n          } else {\n            cursor.continue();\n          }\n        }\n      }, () => resolve(list));\n    });\n\n    return this.list;\n  }\n\n  next(\n    pages = 1,\n    options: boolean | IDBPagingCommandOptions = false,\n  ) {\n    if (typeof options === \"boolean\") {\n      options = { circularPaging: options };\n    }\n    const pageNumber = this.pageNumber + Math.abs(pages);\n    return this.go(pageNumber, options);\n  }\n\n  prev(\n    pages = 1,\n    options: boolean | IDBPagingCommandOptions = false,\n  ) {\n    if (typeof options === \"boolean\") {\n      options = { circularPaging: options };\n    }\n    const pageNumber = this.pageNumber - Math.abs(pages);\n    return this.go(pageNumber, options);\n  }\n\n  first(options?: IDBPagingIndexOptions) {\n    return this.go(1, options);\n  }\n\n  async last(\n    options?: IDBPagingIndexOptions,\n  ) {\n    const lastPageNumber = this.totalPages === 0\n      ? await this.calculateLastPageNumber(options)\n      : this.totalPages;\n\n    // noCheck is true because we already know the last page number\n    return this.go(lastPageNumber, { ...options, noCheck: true });\n  }\n\n  count(options?: IDBPagingIndexOptions) {\n    const index = options?.index ?? this.indexName;\n    const query = options?.query ?? this.query;\n\n    const store = index !== undefined\n      ? idbx.getIndex(this.db, this.storeName, index)\n      : idbx.getStore(this.db, this.storeName);\n\n    const req = store.count(query);\n    return new Promise<number>((resolve, reject) => {\n      req.onsuccess = () => {\n        resolve(req.result);\n      };\n      req.onerror = () => {\n        reject(\"Error retrieving data from IndexedDB\");\n      };\n    });\n  }\n}\n"],
  "mappings": "AAAA,UAAYA,MAAU,WAkBtB,IAAMC,EAAc,OAAO,YAAY,EAE1BC,EAAN,KAAmB,CACxB,GACA,UACA,UACA,MACA,UACA,SACA,CAACD,CAAW,EAAmB,KAC/B,IAAI,YAAa,CACf,OAAO,KAAKA,CAAW,IAAM,KAAO,EAAI,KAAKA,CAAW,CAC1D,CACA,WACA,KAEA,YACEE,EACAC,EACAC,EAA6C,GAC7C,CACA,KAAK,GAAKF,EACV,KAAK,UAAYC,EACb,OAAOC,GAAY,SACrB,KAAK,SAAWA,GAEhB,KAAK,SAAWA,EAAQ,UAAY,GACpC,KAAKJ,CAAW,EAAII,EAAQ,WAAa,EACzC,KAAK,UAAYA,EAAQ,MACzB,KAAK,MAAQA,EAAQ,MACrB,KAAK,UAAYA,EAAQ,WAE3B,KAAK,WAAa,EAClB,KAAK,KAAO,CAAC,CACf,CAEA,MAAM,YACJC,EACAD,EAA6C,EAC7C,CACA,GAAIC,EAAW,EACb,MAAM,IAAI,MAAM,iCAAiC,EAGnD,IAAMC,EAAkB,OAAOF,GAAY,SACvCA,EACAA,EAAQ,WAAa,EACzBA,EAAU,OAAOA,GAAY,SAAW,CAAC,EAAIA,EAE7C,KAAK,SAAWC,EAChB,MAAM,KAAK,GAAGC,EAAiBF,CAAO,CACxC,CAEA,MAAM,wBAAwBA,EAAiC,CAC7D,IAAMG,EAAQ,MAAM,KAAK,MAAMH,CAAO,EACtC,YAAK,WAAa,KAAK,KAAKG,EAAQ,KAAK,QAAQ,EAC1C,KAAK,UACd,CAEA,MAAM,oBACJC,EACAJ,EAAmC,CAAC,EACrB,CACf,IAAMK,EAAUL,EAAQ,UAAY,OAAY,GAAQA,EAAQ,QAC1DM,EAAiBN,EAAQ,iBAAmB,OAC9C,GACAA,EAAQ,eAGZ,GADA,KAAKJ,CAAW,EAAI,SAASQ,EAAW,SAAS,EAAG,EAAE,GAAK,KAAK,WAC5D,CAACC,GAAWC,EAAgB,CAC9B,IAAMC,EAAiB,MAAM,KAAK,wBAAwBP,CAAO,EACjE,GAAI,KAAK,WAAa,EACpB,GAAIM,EAAgB,CAClB,IAAME,EAAY,KAAK,IAAI,KAAK,UAAU,EAAID,EAC9C,KAAKX,CAAW,EAAIY,GAAa,EAAID,EAAiBC,EAAY,CACpE,MACE,KAAKZ,CAAW,EAAI,UAGlB,KAAK,WAAaW,EACpB,GAAID,EAAgB,CAClB,IAAME,EAAY,KAAK,WAAaD,EACpC,KAAKX,CAAW,EAAIY,EAAY,EAAIA,EAAYD,CAClD,MACE,KAAKX,CAAW,EAAIW,CAI5B,CACF,CAEA,MAAM,GAAGH,EAAoBJ,EAAmC,CAC9D,QAAS,GACT,eAAgB,EAClB,EAAiB,CACf,MAAM,KAAK,oBAAoBI,EAAYJ,CAAO,EAClD,IAAMS,GAAU,KAAK,WAAa,GAAK,KAAK,SACxCC,EAAY,GAEVC,EAAQX,EAAQ,OAAS,KAAK,UAC9BY,EAAQZ,EAAQ,OAAS,KAAK,MAC9Ba,EAAYb,EAAQ,WAAa,KAAK,UAE5C,YAAK,KAAO,MAAM,IAAI,QAASc,GAAY,CACzC,IAAMC,EAAY,CAAC,EAMbC,GAJQL,IAAU,OACf,WAAS,KAAK,GAAI,KAAK,UAAWA,CAAK,EACvC,WAAS,KAAK,GAAI,KAAK,SAAS,GAEnB,WAAWC,EAAOC,CAAS,EAC5C,gBAAcG,EAAUC,GAAW,CACtC,GAAIP,GAAaD,EAAS,EACxBC,EAAY,GACZO,EAAO,QAAQR,CAAM,MAChB,CAML,GALI,KAAK,UAAYM,EAAK,SACpB,CAACf,GAAS,OAASiB,EAAO,MAAQjB,GAAS,QAC7Ce,EAAK,KAAKE,EAAO,KAAK,EAGtB,KAAK,WAAaF,EAAK,OAEzB,MAAO,GAEPE,EAAO,SAAS,CAEpB,CACF,EAAG,IAAMH,EAAQC,CAAI,CAAC,CACxB,CAAC,EAEM,KAAK,IACd,CAEA,KACEG,EAAQ,EACRlB,EAA6C,GAC7C,CACI,OAAOA,GAAY,YACrBA,EAAU,CAAE,eAAgBA,CAAQ,GAEtC,IAAMI,EAAa,KAAK,WAAa,KAAK,IAAIc,CAAK,EACnD,OAAO,KAAK,GAAGd,EAAYJ,CAAO,CACpC,CAEA,KACEkB,EAAQ,EACRlB,EAA6C,GAC7C,CACI,OAAOA,GAAY,YACrBA,EAAU,CAAE,eAAgBA,CAAQ,GAEtC,IAAMI,EAAa,KAAK,WAAa,KAAK,IAAIc,CAAK,EACnD,OAAO,KAAK,GAAGd,EAAYJ,CAAO,CACpC,CAEA,MAAMA,EAAiC,CACrC,OAAO,KAAK,GAAG,EAAGA,CAAO,CAC3B,CAEA,MAAM,KACJA,EACA,CACA,IAAMO,EAAiB,KAAK,aAAe,EACvC,MAAM,KAAK,wBAAwBP,CAAO,EAC1C,KAAK,WAGT,OAAO,KAAK,GAAGO,EAAgB,CAAE,GAAGP,EAAS,QAAS,EAAK,CAAC,CAC9D,CAEA,MAAMA,EAAiC,CACrC,IAAMW,EAAQX,GAAS,OAAS,KAAK,UAC/BY,EAAQZ,GAAS,OAAS,KAAK,MAM/BmB,GAJQR,IAAU,OACf,WAAS,KAAK,GAAI,KAAK,UAAWA,CAAK,EACvC,WAAS,KAAK,GAAI,KAAK,SAAS,GAEvB,MAAMC,CAAK,EAC7B,OAAO,IAAI,QAAgB,CAACE,EAASM,IAAW,CAC9CD,EAAI,UAAY,IAAM,CACpBL,EAAQK,EAAI,MAAM,CACpB,EACAA,EAAI,QAAU,IAAM,CAClBC,EAAO,sCAAsC,CAC/C,CACF,CAAC,CACH,CACF",
  "names": ["idbx", "PAGE_NUMBER", "IDBPaging", "db", "storeName", "options", "pageSize", "startPageNumber", "count", "pageNumber", "noCheck", "circularPaging", "lastPageNumber", "flipPages", "offset", "advancing", "index", "query", "direction", "resolve", "list", "request", "cursor", "pages", "req", "reject"]
}
